package org.eclipse.core.internal.resources;

/*
 * (c) Copyright IBM Corp. 2000, 2001, 2002.
 * All Rights Reserved.
 */

import org.eclipse.core.runtime.*;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.resources.*;
import org.eclipse.core.resources.IResourceVisitor;
import org.eclipse.core.internal.localstore.*;
import org.eclipse.core.internal.properties.PropertyManager;
import org.eclipse.core.internal.utils.*;
import org.eclipse.core.internal.watson.*;
import java.io.*;
import java.util.*;
import java.net.URL;
import java.net.MalformedURLException;

public abstract class Resource extends PlatformObject implements IResource, ICoreConstants, Cloneable {
	/* package */ IPath path;
	/* package */ Workspace workspace;
protected Resource(IPath path, Workspace workspace) {
	this.path = path.removeTrailingSeparator();
	this.workspace = workspace;
}

/**
 * @see IResource#accept(IResourceVisitor)
 */
public void accept(IResourceVisitor visitor) throws CoreException {
	// forward to central method
	accept(visitor, IResource.DEPTH_INFINITE, 0);
}

/**
 * @see IResource#accept(IResourceVisitor, int, boolean)
 */
public void accept(IResourceVisitor visitor, int depth, boolean includePhantoms) throws CoreException {
	// forward to central method
	accept(visitor, depth, includePhantoms ? IContainer.INCLUDE_PHANTOMS : 0);
}

/*
 * @see IResource#accept
 */
public void accept(IResourceVisitor visitor, int depth, int memberFlags) throws CoreException {
	// FIXME - handle team private members
	final boolean includePhantoms = (memberFlags & IContainer.INCLUDE_PHANTOMS) != 0;
	ResourceInfo info = getResourceInfo(includePhantoms, false);
	checkExists(getFlags(info), true);
	if (!visitor.visit(this) || depth == DEPTH_ZERO)
		return;
	// get the info again because it might have been changed by the visitor
	info = getResourceInfo(includePhantoms, false);
	if (info == null)
		return;
	// thread safety: (cache the type to avoid changes -- we might not be inside an operation)
	int type = info.getType();
	if (type == FILE)
		return;
	if (depth == DEPTH_ONE)
		depth = DEPTH_ZERO;
	// if we had a gender change we need to fix up the resource before asking for its members
	IContainer resource = getType() != type ? (IContainer) workspace.newResource(getFullPath(), type) : (IContainer) this;
	IResource[] members = resource.members(memberFlags);
	for (int i = 0; i < members.length; i++)
		members[i].accept(visitor, depth, memberFlags);
}

protected void assertCopyRequirements(IPath destination, int destinationType) throws CoreException {
	IStatus status = checkCopyRequirements(destination, destinationType);
	if (!status.isOK()) {
		// this assert is ok because the error cases generated by the
		// check method above indicate assertion conditions.
		Assert.isTrue(false, status.getChildren()[0].getMessage());
	}
}
protected void assertMoveRequirements(IPath destination, int destinationType) throws CoreException {
	IStatus status = checkMoveRequirements(destination, destinationType);
	if (!status.isOK()) {
		// this assert is ok because the error cases generated by the
		// check method above indicate assertion conditions.
		Assert.isTrue(false, status.getChildren()[0].getMessage());
	}
}
public void checkAccessible(int flags) throws CoreException {
	checkExists(flags, true);
}
/**
 * This method reports errors in two different ways. It can throw a
 * CoreException or log a status. CoreExceptions are used according
 * to the specification of the copy method. Programming errors, that
 * would usually be prevented by using an "Assert" code, are reported as
 * an IStatus.
 * We're doing this way because we have two different methods to copy
 * resources: IResource#copy and IWorkspace#copy. The first one gets
 * the error and throws its message in an AssertionFailureException. The
 * second one just throws a CoreException using the status returned
 * by this method.
 * 
 * @see IResource#copy
 */
public IStatus checkCopyRequirements(IPath destination, int destinationType) throws CoreException {
	String message = Policy.bind("resources.copyNotMet");
	MultiStatus status = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.INVALID_VALUE, message, null);
	if (destination == null) {
		message = Policy.bind("resources.destNotNull");
		return new ResourceStatus(IResourceStatus.INVALID_VALUE, getFullPath(), message);
	}
	destination = makePathAbsolute(destination);
	if (getFullPath().isPrefixOf(destination)) {
		message = Policy.bind("resources.destNotSub");
		status.add(new ResourceStatus(IResourceStatus.INVALID_VALUE, getFullPath(), message));
	}
	checkValidPath(destination, destinationType);

	ResourceInfo info = getResourceInfo(false, false);
	int flags = getFlags(info);
	checkAccessible(flags);
	checkLocal(flags, DEPTH_INFINITE);

	Resource dest = (Resource) workspace.newResource(destination, destinationType);
	dest.checkDoesNotExist();

	// ensure we aren't trying to copy a file to a project
	if (getType() == IResource.FILE && dest.getType() == IResource.PROJECT) {
		message = Policy.bind("resources.fileToProj");
		throw new ResourceException(new ResourceStatus(IResourceStatus.INVALID_VALUE, getFullPath(), message));
	}

	// we can't copy into a closed project
	if (destinationType != IResource.PROJECT) {
		Project project = (Project) dest.getProject();
		info = project.getResourceInfo(false, false);
		project.checkAccessible(getFlags(info));

		Container parent = (Container) dest.getParent();
		if (!parent.equals(project)) {
			info = parent.getResourceInfo(false, false);
			parent.checkExists(getFlags(info), true);
		}
	}

	return status.isOK() ? (IStatus) new ResourceStatus(IResourceStatus.OK, Policy.bind("resources.copyMet")) : (IStatus) status;
}
/**
 * Checks that this resource does not exist.  
 *
 * @exception CoreException if this resource exists
 */
public void checkDoesNotExist(int flags, boolean checkType) throws CoreException {
	// See if there is any resource at all.  If none then we are happy.
	if (!exists(flags, false))
		return;
	// We know there is something in the tree at this path.
	// If we are checking type then go ahead and check the type.
	// If there is nothing there of this resource's type, then return.
	if ((checkType && !exists(flags, checkType)))
		return;
	String message = Policy.bind("resources.mustNotExist", getFullPath().toString());
	throw new ResourceException(checkType ? IResourceStatus.RESOURCE_EXISTS : IResourceStatus.PATH_OCCUPIED, getFullPath(), message, null);
}
/**
 * Checks that this resource exists.
 * If checkType is true, the type of this resource and the one in the tree must match.
 *
 * @exception CoreException if this resource does not exist
 */
public void checkExists(int flags, boolean checkType) throws CoreException {
	if (!exists(flags, checkType)) {
		String message = Policy.bind("resources.mustExist", getFullPath().toString());
		throw new ResourceException(IResourceStatus.RESOURCE_NOT_FOUND, getFullPath(), message, null);
	}
}
/**
 * Checks that this resource is local to the given depth.  
 *
 * @exception CoreException if this resource is not local
 */
public void checkLocal(int flags, int depth) throws CoreException {
	if (!isLocal(flags, depth)) {
		String message = Policy.bind("resources.mustBeLocal", getFullPath().toString());
		throw new ResourceException(IResourceStatus.RESOURCE_NOT_LOCAL, getFullPath(), message, null);
	}
}
/**
 * This method reports errors in two different ways. It can throw a
 * CoreException or log a status. CoreExceptions are used according
 * to the specification of the move method. Programming errors, that
 * would usually be prevented by using an "Assert" code, are reported as
 * an IStatus.
 * We're doing this way because we have two different methods to move
 * resources: IResource#move and IWorkspace#move. The first one gets
 * the error and throws its message in an AssertionFailureException. The
 * second one just throws a CoreException using the status returned
 * by this method.
 * 
 * @see IResource#move
 */
protected IStatus checkMoveRequirements(IPath destination, int destinationType) throws CoreException {
	String message = Policy.bind("resources.moveNotMet");
	MultiStatus status = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.INVALID_VALUE, message, null);
	if (destination == null) {
		message = Policy.bind("resources.destNotNull");
		return new ResourceStatus(IResourceStatus.INVALID_VALUE, getFullPath(), message);
	}
	destination = makePathAbsolute(destination);
	if (getFullPath().isPrefixOf(destination)) {
		message = Policy.bind("resources.destNotSub");
		status.add(new ResourceStatus(IResourceStatus.INVALID_VALUE, getFullPath(), message));
	}
	checkValidPath(destination, destinationType);

	ResourceInfo info = getResourceInfo(false, false);
	int flags = getFlags(info);
	checkAccessible(flags);
	checkLocal(flags, DEPTH_INFINITE);

	Resource dest = (Resource) workspace.newResource(destination, destinationType);
	
	// check if we are only changing case
	IResource variant = CoreFileSystemLibrary.isCaseSensitive() ? null : findExistingResourceVariant(destination);
	if (variant == null || !this.equals(variant))
		dest.checkDoesNotExist();

	// ensure we aren't trying to move a file to a project
	if (getType() == IResource.FILE && dest.getType() == IResource.PROJECT) {
		message = Policy.bind("resources.fileToProj");
		throw new ResourceException(new ResourceStatus(IResourceStatus.INVALID_VALUE, getFullPath(), message));
	}

	// we can't move into a closed project
	if (destinationType != IResource.PROJECT) {
		Project project = (Project) dest.getProject();
		info = project.getResourceInfo(false, false);
		project.checkAccessible(getFlags(info));

		Container parent = (Container) dest.getParent();
		if (!parent.equals(project)) {
			info = parent.getResourceInfo(false, false);
			parent.checkExists(getFlags(info), true);
		}
	}
	return status.isOK() ? (IStatus) new ResourceStatus(IResourceStatus.OK, Policy.bind("resources.moveMet")) : (IStatus) status;
}
/**
 * Checks that the supplied path is valid according to Workspace.validatePath().
 *
 * @exception CoreException if the path is not valid
 */
public void checkValidPath(IPath path, int type) throws CoreException {
	IStatus result = workspace.validatePath(path.toString(), type);
	if (!result.isOK())
		throw new ResourceException(result);
}
/**
 * @see IResource
 */
public void clearHistory(IProgressMonitor monitor) throws CoreException {
	getLocalManager().getHistoryStore().removeAll(this);
}
public void convertToPhantom() throws CoreException {
	ResourceInfo info = getResourceInfo(false, true);
	if (info == null || isPhantom(getFlags(info)))
		return;
	info.clearSessionProperties();
	info.set(M_PHANTOM);
	getLocalManager().updateLocalSync(info, I_NULL_SYNC_INFO, getType() == FILE);
	info.setModificationStamp(IResource.NULL_STAMP);
	// should already be done by the #deleteResource call but left in 
	// just to be safe and for code clarity.
	info.setMarkers(null);
}

/*
 * Used when a folder is to be copied to a project.
 * @see IResource#copy
 */
public void copy(IProjectDescription destDesc, int updateFlags, IProgressMonitor monitor) throws CoreException {
	// FIXME
	copy(destDesc, (updateFlags & IResource.FORCE) != 0, monitor);
}

/*
 * @see IResource#copy
 */
public void copy(IProjectDescription destDesc, boolean force, IProgressMonitor monitor) throws CoreException {
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.copying", getFullPath().toString());
		monitor.beginTask(message, Policy.totalWork);
		try {
			workspace.prepareOperation();
			// The following assert method throws CoreExceptions as stated in the IResource.copy API
			// and assert for programming errors. See checkCopyRequirements for more information.
			IPath destPath = new Path(destDesc.getName()).makeAbsolute();
			assertCopyRequirements(destPath, IResource.PROJECT);
			Project destProject = (Project) workspace.getRoot().getProject(destPath.lastSegment());
			workspace.beginOperation(true);

			// create and open the new project
			destProject.create(destDesc, Policy.subMonitorFor(monitor, Policy.opWork * 5 / 100));
			destProject.open(Policy.subMonitorFor(monitor, Policy.opWork * 5 / 100));

			// copy the children
			// FIXME: fix the progress monitor here...create a sub monitor and do a worked(1) after each child instead
			IResource[] children = ((IContainer) this).members();
			for (int i = 0; i < children.length; i++) {
				Resource child = (Resource) children[i];
				child.copy(destPath.append(child.getName()), force, Policy.subMonitorFor(monitor, Policy.opWork * 60 / 100 / children.length));
			}

			// copy over the properties
			getPropertyManager().copy(this, destProject, DEPTH_ZERO);
			monitor.worked(Policy.opWork * 15 / 100);

		} catch (OperationCanceledException e) {
			workspace.getWorkManager().operationCanceled();
			throw e;
		} finally {
			workspace.endOperation(true, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}

/**
 * @see IResource#copy
 */
public void copy(IPath destination, int updateFlags, IProgressMonitor monitor) throws CoreException {
	// FIXME
	copy(destination, (updateFlags & IResource.FORCE) != 0, monitor);
}

/**
 * @see IResource#copy
 */
public void copy(IPath destination, boolean force, IProgressMonitor monitor) throws CoreException {
	if (destination.isAbsolute() && destination.segmentCount() == 1) {
		copy(workspace.newProjectDescription(destination.lastSegment()), force, monitor);
		return;
	}
	try {
		monitor = Policy.monitorFor(monitor);
		String message = Policy.bind("resources.copying", getFullPath().toString());
		monitor.beginTask(message, Policy.totalWork);
		try {
			workspace.prepareOperation();
			// The following assert method throws CoreExceptions as stated in the IResource.copy API
			// and assert for programming errors. See checkCopyRequirements for more information.
			assertCopyRequirements(destination, getType());

			workspace.beginOperation(true);
			Resource destResource = workspace.newResource(makePathAbsolute(destination), getType());
			getLocalManager().copy(this, destResource, force, Policy.subMonitorFor(monitor, Policy.opWork));
		} catch (OperationCanceledException e) {
			workspace.getWorkManager().operationCanceled();
			throw e;
		} finally {
			workspace.endOperation(true, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}

/**
 * Count the number of resources in the tree from this container to the
 * specified depth. Include this resource. Include phantoms if
 * the phantom boolean is true.
 */
public int countResources(int depth, boolean phantom) throws CoreException {
	return workspace.countResources(path, depth, phantom);
}
/**
 * @see IResource
 */
public IMarker createMarker(String type) throws CoreException {
	Assert.isNotNull(type);
	try {
		workspace.prepareOperation();
		ResourceInfo resourceInfo = getResourceInfo(false, false);
		checkAccessible(getFlags(resourceInfo));

		workspace.beginOperation(true);
		MarkerInfo info = new MarkerInfo();
		info.setType(type);
		workspace.getMarkerManager().add(this, new MarkerInfo[] { info });
		return new Marker(this, info.getId());
	} finally {
		workspace.endOperation(false, null);
	}
}

/**
 * @see IResource
 */
public void delete(boolean force, IProgressMonitor monitor) throws CoreException {
	delete(force, false, monitor);
}

/**
 * @see IResource
 */
public void delete(int updateFlags, IProgressMonitor monitor) throws CoreException {
	// FIXME
	final boolean force = (updateFlags & IResource.FORCE) != 0;
	final boolean keepHistory = (updateFlags & IResource.KEEP_HISTORY) != 0;
	delete(force, keepHistory, monitor);
}

/**
 * @see IProject and IWorkspaceRoot -- N.B. This is not an IResource method!
 */
public void delete(boolean force, boolean keepHistory, IProgressMonitor monitor) throws CoreException {
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.deleting", getFullPath().toString());
		monitor.beginTask(message, Policy.totalWork);
		try {
			workspace.prepareOperation();
			/* if there is no such resource (including type check) then there is nothing
			   to delete so just return. */
			if (!exists())
				return;

			workspace.beginOperation(true);
			getLocalManager().delete(this, force, true, keepHistory, Policy.subMonitorFor(monitor, Policy.opWork));
		} catch (OperationCanceledException e) {
			workspace.getWorkManager().operationCanceled();
			throw e;
		} finally {
			workspace.endOperation(true, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}
/**
 * @see IResource
 */
public void deleteMarkers(String type, boolean includeSubtypes, int depth) throws CoreException {
	try {
		workspace.prepareOperation();
		ResourceInfo info = getResourceInfo(false, false);
		checkAccessible(getFlags(info));

		workspace.beginOperation(true);
		workspace.getMarkerManager().removeMarkers(this, type, includeSubtypes, depth);
	} finally {
		workspace.endOperation(false, null);
	}
}
/**
 * This method should be called to delete a resource from the tree because it will also
 * delete its properties and markers.  If a status object is provided, minor exceptions are
 * added, otherwise they are thrown.  If major exceptions occur, they are always thrown.
 */
public void deleteResource(boolean convertToPhantom, MultiStatus status) throws CoreException {
	/* delete properties */
	CoreException err = null;
	try {
		getPropertyManager().deleteProperties(this);
	} catch (CoreException e) {
		if (status != null)
			status.add(e.getStatus());
		else 
			err = e;
	}
	/* remove markers on this resource and its descendents. */
	if (exists())
		getMarkerManager().removeMarkers(this);
	/* if we are synchronizing, do not delete the resource. Convert it
	   into a phantom. Actual deletion will happen when we refresh or push. */
	if (convertToPhantom && getType() != PROJECT && synchronizing(getResourceInfo(true, false)))
		convertToPhantom();
	else
		workspace.deleteResource(this);
	if (err != null)
		throw err;
}
/**
 * @see IResource#equals
 */
public boolean equals(Object target) {
	if (this == target)
		return true;
	if (!(target instanceof Resource))
		return false;
	Resource resource = (Resource) target;
	return getType() == resource.getType() && path.equals(resource.path) && workspace.equals(resource.workspace);
}
/**
 * @see IResource#exists
 */
public boolean exists() {
	ResourceInfo info = getResourceInfo(false, false);
	return exists(getFlags(info), true);
}
public boolean exists(int flags, boolean checkType) {
	return flags != NULL_FLAG && !(checkType && ResourceInfo.getType(flags) != getType());
}
/**
 * @see IResource#findMarker
 */
public IMarker findMarker(long id) throws CoreException {
	return workspace.getMarkerManager().findMarker(this, id);
}
/**
 * @see IResource#findMarkers
 */
public IMarker[] findMarkers(String type, boolean includeSubtypes, int depth) throws CoreException {
	ResourceInfo info = getResourceInfo(false, false);
	checkAccessible(getFlags(info));
	// It might happen that from this point the resource is not accessible anymore.
	// But markers have the #exists method that callers can use to check if it is
	// still valid.
	return workspace.getMarkerManager().findMarkers(this, type, includeSubtypes, depth);
}
protected void fixupAfterMoveSource() throws CoreException {
	ResourceInfo info = getResourceInfo(true, true);
	if (!synchronizing(info)) {
		workspace.deleteResource(this);
		return;
	}
	info.clearSessionProperties();
	info.clear(M_LOCAL_EXISTS);
	info.setLocalSyncInfo(I_NULL_SYNC_INFO);
	info.set(M_PHANTOM);
	info.setModificationStamp(IResource.NULL_STAMP);
	info.setMarkers(null);
}
/**
 * @see IResource#getFileExtension
 */
public String getFileExtension() {
	String name = getName();
	int index = name.lastIndexOf('.');
	if (index == -1)
		return null;
	if (index == (name.length() - 1))
		return "";
	return name.substring(index + 1);
}
public int getFlags(ResourceInfo info) {
	return (info == null) ? NULL_FLAG : info.getFlags();
}
/**
 * @see IResource#getFullPath
 */
public IPath getFullPath() {
	return path;
}
public FileSystemResourceManager getLocalManager() {
	return workspace.getFileSystemManager();
}
/**
 * @see IResource#getLocation
 */
public IPath getLocation() {
	IProject project = getProject();
	if (project != null && !project.exists())
		return null;
	return getLocalManager().locationFor(this);
}

/**
 * @see IResource#getLocationURL
 */
public URL getLocationURL() {
	IProject project = getProject();
	if (project != null && !project.exists())
		return null;
	try {
		return new URL("platform:/resource" + getFullPath());
	} catch (MalformedURLException e) {
		return null;
	}
}
/**
 * @see IResource
 */
public IMarker getMarker(long id) {
	return new Marker(this, id);
}
protected MarkerManager getMarkerManager() {
	return workspace.getMarkerManager();
}
/**
 * @see IResource
 */
public long getModificationStamp() {
	ResourceInfo info = getResourceInfo(false, false);
	return info == null ? IResource.NULL_STAMP : info.getModificationStamp();
}
/**
 * @see IResource#getName
 */
public String getName() {
	return path.lastSegment();
}
/**
 * @see IResource#getParent
 */
public IContainer getParent() {
	IPath parent = path.removeLastSegments(1);
	if (parent.isRoot() || parent.isEmpty())
		return null;
	if (parent.segmentCount() == 1)
		return workspace.getRoot().getProject(parent.lastSegment());
	else
		return workspace.getRoot().getFolder(parent);
}
/**
 * @see IResource
 */
public String getPersistentProperty(QualifiedName key) throws CoreException {
	ResourceInfo info = getResourceInfo(false, false);
	int flags = getFlags(info);
	checkAccessible(flags);
	checkLocal(flags, DEPTH_ZERO);
	return getPropertyManager().getProperty(this, key);
}
/**
 * @see IResource#getProject
 */
public IProject getProject() {
	return workspace.getRoot().getProject(path.segment(0));
}
/**
 * @see IResource#getProjectRelativePath
 */
public IPath getProjectRelativePath() {
	return getFullPath().removeFirstSegments(ICoreConstants.PROJECT_SEGMENT_LENGTH);
}
public PropertyManager getPropertyManager() {
	return workspace.getPropertyManager();
}
/**
 * Returns the resource info.  Returns null if the resource doesn't exist.
 * If the phantom flag is true, phantom resources are considered.
 * If the mutable flag is true, a mutable info is returned.
 */
public ResourceInfo getResourceInfo(boolean phantom, boolean mutable) {
	return workspace.getResourceInfo(getFullPath(), phantom, mutable);
}
/**
 * @see IResource
 */
public Object getSessionProperty(QualifiedName key) throws CoreException {
	ResourceInfo info = getResourceInfo(false, false);
	int flags = getFlags(info);
	checkAccessible(flags);
	checkLocal(flags, DEPTH_ZERO);
	return info.getSessionProperty(key);
}
/**
 * @see IResource#getType
 */
public abstract int getType();
public String getTypeString() {
	switch (getType()) {
		case FILE :
			return "L";
		case FOLDER :
			return "F";
		case PROJECT :
			return "P";
		case ROOT:
			return "R";
	}
	return "";
}
/**
 * @see IResource#getWorkspace
 */
public IWorkspace getWorkspace() {
	return workspace;
}
public int hashCode() {
	// the container may be null if the identified resource 
	// does not exist so don't bother with it in the hash
	return getFullPath().hashCode();
}
/**
 * Sets the M_LOCAL_EXISTS flag. Is internal so we don't have
 * to begin an operation.
 */
protected void internalSetLocal(boolean flag, int depth) throws CoreException {
	ResourceInfo info = getResourceInfo(true, true);
	//only make the change if it's not already in desired state
	if (info.isSet(M_LOCAL_EXISTS) != flag) {
		if (flag && !isPhantom(getFlags(info))) {
			info.set(M_LOCAL_EXISTS);
			workspace.updateModificationStamp(info);
		} else {
			info.clear(M_LOCAL_EXISTS);
			info.setModificationStamp(IResource.NULL_STAMP);
		}
	}
	if (getType() == IResource.FILE || depth == IResource.DEPTH_ZERO)
		return;
	if (depth == IResource.DEPTH_ONE)
		depth = IResource.DEPTH_ZERO;
	IResource[] children = ((IContainer) this).members();
	for (int i = 0; i < children.length; i++)
		 ((Resource) children[i]).internalSetLocal(flag, depth);
}
/**
 * @see IResource
 */
public boolean isAccessible() {
	return exists();
}
/**
 * @see IResource
 */
public boolean isLocal(int depth) {
	ResourceInfo info = getResourceInfo(false, false);
	return isLocal(getFlags(info), depth);
}
public boolean isLocal(int flags, int depth) {
	if (getType() == PROJECT)
		return flags != NULL_FLAG; // exists
	else
		return flags != NULL_FLAG && ResourceInfo.isSet(flags, M_LOCAL_EXISTS);
}
/**
 * @see IResource
 */
public boolean isPhantom() {
	ResourceInfo info = getResourceInfo(true, false);
	return isPhantom(getFlags(info));
}
public boolean isPhantom(int flags) {
	return flags != NULL_FLAG && ResourceInfo.isSet(flags, M_PHANTOM);
}
/**
 * @see IResource
 */
public boolean isReadOnly() {
	IPath location = getLocation();
	if (location == null)
		return false;
	return CoreFileSystemLibrary.isReadOnly(location.toOSString());
}
protected IPath makePathAbsolute(IPath target) {
	if (target.isAbsolute())
		return target;
	return getParent().getFullPath().append(target);
}

/*
 * @see IResource#move
 */
public void move(IProjectDescription destDesc, boolean force, boolean keepHistory, IProgressMonitor monitor) throws CoreException {
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.moving", getFullPath().toString());
		monitor.beginTask(message, Policy.totalWork);
		try {
			workspace.prepareOperation();
			// The following assert method throws CoreExceptions as stated in the IResource.move API
			// and assert for programming errors. See checkCopyRequirements for more information.
			IPath destPath = Path.ROOT.append(destDesc.getName());
			assertMoveRequirements(destPath, IResource.PROJECT);
			// copy the original properties to the new location and then move the resources
			// on disk.  If the move fails then delete the newly copied properties.  Otherwise, 
			// move the resources in the tree and delete the original (already copied) properties.
			Project destProject = (Project) workspace.getRoot().getProject(destDesc.getName());

			workspace.beginOperation(true);

			// create and open the new project and reset the node id so it looks like a move rather
			// than a create.
			destProject.create(destDesc, Policy.subMonitorFor(monitor, Policy.opWork * 5 / 100));
			destProject.open(Policy.subMonitorFor(monitor, Policy.opWork * 5 / 100));
			destProject.getResourceInfo(false, true).setNodeId(getResourceInfo(false, false).getNodeId());

			// move the children
			// FIXME: fix the progress monitor here...create a sub monitor and do a worked(1) after each child instead
			IResource[] children = ((IContainer) this).members();
			for (int i = 0; i < children.length; i++) {
				Resource child = (Resource) children[i];
				child.move(destPath.append(child.getName()), force, keepHistory, Policy.subMonitorFor(monitor, Policy.opWork * 40 / 100 / children.length));
			}

			// copy over the properties
			getPropertyManager().copy(this, destProject, DEPTH_ZERO);
			monitor.worked(Policy.opWork * 10 / 100);

			// generate the appropriate marker deltas
			getMarkerManager().moved(this, destProject, IResource.DEPTH_INFINITE);
			monitor.worked(Policy.opWork * 10 / 100);

			// delete the source
			delete(force, keepHistory, Policy.subMonitorFor(monitor, Policy.opWork * 30 / 100));

		} catch (OperationCanceledException e) {
			workspace.getWorkManager().operationCanceled();
			throw e;
		} finally {
			workspace.endOperation(true, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}

/*
 * Used when a folder is to be moved to a project.
 * @see IResource#move
 */
public void move(IProjectDescription destDesc, int updateFlags, IProgressMonitor monitor) throws CoreException {
	// FIXME
	final boolean force = (updateFlags & IResource.FORCE) != 0;
	final boolean keepHistory = (updateFlags & IResource.KEEP_HISTORY) != 0;
	move(destDesc, force, keepHistory, monitor);
}

/**
 * @see IResource#move
 */
public void move(IPath destination, boolean force, IProgressMonitor monitor) throws CoreException {
	move(destination, force, false, monitor);
}

/**
 * @see IResource#move
 */
public void move(IPath destination, boolean force, boolean keepHistory, IProgressMonitor monitor) throws CoreException {
	if (destination.isAbsolute() && destination.segmentCount() == 1) {
		move(workspace.newProjectDescription(destination.lastSegment()), force, keepHistory, monitor);
		return;
	}
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.moving", getFullPath().toString());
		monitor.beginTask(message, Policy.totalWork);
		try {
			workspace.prepareOperation();
			// The following assert method throws CoreExceptions as stated in the IResource.move API
			// and assert for programming errors. See checkCopyRequirements for more information.
			assertMoveRequirements(destination, getType());
			destination = makePathAbsolute(destination);
			// copy the original properties to the new location and then move the resources
			// on disk.  If the move fails then delete the newly copied properties.  Otherwise, 
			// move the resources in the tree and delete the original (already copied) properties.
			Resource dest = (Resource) workspace.newResource(destination, getType());

			workspace.beginOperation(true);
			boolean success = false;
			try {
				getPropertyManager().copy(this, dest, DEPTH_INFINITE);
				monitor.worked(Policy.opWork * 20 / 100);
				moveInFileSystem(destination, force, keepHistory, Policy.subMonitorFor(monitor, Policy.opWork * 20 / 100));
				success = true;
			} finally {
				if (!success) {
					// if we got here some exception was thrown
					try {
						getPropertyManager().deleteProperties(dest);
					} catch (CoreException ex) {
						// we don't want to throw this CoreException
					}
					// and the first exception is thrown from here
				}
			}
			getPropertyManager().deleteProperties(this);
			monitor.worked(Policy.opWork * 20 / 100);
			workspace.move(this, destination);
			getMarkerManager().moved(this, dest, IResource.DEPTH_INFINITE);
			monitor.worked(Policy.opWork * 20 / 100);
		} catch (OperationCanceledException e) {
			workspace.getWorkManager().operationCanceled();
			throw e;
		} finally {
			workspace.endOperation(true, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}

/**
 * @see IResource#move
 */
public void move(IPath destination, int updateFlags, IProgressMonitor monitor) throws CoreException {
	// FIXME
	final boolean force = (updateFlags & IResource.FORCE) != 0;
	final boolean keepHistory = (updateFlags & IResource.KEEP_HISTORY) != 0;
	move(destination, force, keepHistory, monitor);
}

protected void moveInFileSystem(IPath destination, boolean force, boolean keepHistory, IProgressMonitor monitor) throws CoreException {
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.moving", getFullPath().toString());
		monitor.beginTask(message, 100);
		message = Policy.bind("resources.moveProblem");
		RefreshLocalWithStatusVisitor visitor = new RefreshLocalWithStatusVisitor(message, monitor);
		UnifiedTree tree = new UnifiedTree(this);
		tree.accept(visitor, DEPTH_INFINITE);
		/* if force is false and resources were not in sync, throw an exception */
		if (!force)
			if (!visitor.getStatus().isOK())
				throw new ResourceException(visitor.getStatus());
		getLocalManager().move(this, destination, keepHistory, Policy.subMonitorFor(monitor, 70));
	} finally {
		monitor.done();
	}
}
/**
 * @see IResource#refreshLocal
 */
public void refreshLocal(int depth, IProgressMonitor monitor) throws CoreException {
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.refreshing", getFullPath().toString());
		monitor.beginTask(message, Policy.totalWork);
		boolean build = false;
		try {
			workspace.prepareOperation();
			if (getType() != ROOT && !getProject().isAccessible())
				return;
			workspace.beginOperation(true);
			build = getLocalManager().refresh(this, depth, Policy.subMonitorFor(monitor, Policy.opWork));
		} catch (OperationCanceledException e) {
			workspace.getWorkManager().operationCanceled();
			throw e;
		} finally {
			workspace.endOperation(build, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}
/**
 * @see IResource
 */
public void setLocal(boolean flag, int depth, IProgressMonitor monitor) throws CoreException {
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.setLocal");
		monitor.beginTask(message, Policy.totalWork);
		try {
			workspace.prepareOperation();
			workspace.beginOperation(true);
			internalSetLocal(flag, depth);
			monitor.worked(Policy.opWork);
		} finally {
			workspace.endOperation(true, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}
/**
 * @see IResource
 */
public void setPersistentProperty(QualifiedName key, String value) throws CoreException {
	ResourceInfo info = getResourceInfo(false, false);
	int flags = getFlags(info);
	checkAccessible(flags);
	checkLocal(flags, DEPTH_ZERO);
	getPropertyManager().setProperty(this, key, value);
}
/**
 * @see IResource
 */
public void setReadOnly(boolean readonly) {
	CoreFileSystemLibrary.setReadOnly(getLocation().toOSString(), readonly);
}
/**
 * @see IResource
 */
public void setSessionProperty(QualifiedName key, Object value) throws CoreException {
	// fetch the info but don't bother making it mutable even though we are going
	// to modify it.  We don't know whether or not the tree is open and it really doesn't
	// matter as the change we are doing does not show up in deltas.
	ResourceInfo info = getResourceInfo(false, false);
	int flags = getFlags(info);
	checkAccessible(flags);
	checkLocal(flags, DEPTH_ZERO);
	info.setSessionProperty(key, value);
}
/**
 * Returns true if this resource has the potential to be
 * (or have been) synchronized.  
 */
public boolean synchronizing(ResourceInfo info) {
	return info != null && info.getSyncInfo(false) != null;
}
public String toString() {
	return getTypeString() + getFullPath().toString();
}
/**
 * @see IResource
 */
public void touch(IProgressMonitor monitor) throws CoreException {
	monitor = Policy.monitorFor(monitor);
	try {
		String message = Policy.bind("resources.touch", getFullPath().toString());
		monitor.beginTask(message, Policy.totalWork);
		try {
			workspace.prepareOperation();
			ResourceInfo info = getResourceInfo(false, false);
			int flags = getFlags(info);
			checkAccessible(flags);
			checkLocal(flags, DEPTH_ZERO);

			workspace.beginOperation(true);
			// fake a change by incrementing the content ID
			info = getResourceInfo(false, true);
			info.incrementContentId();
			workspace.updateModificationStamp(info);
			monitor.worked(Policy.opWork);
		} catch (OperationCanceledException e) {
			workspace.getWorkManager().operationCanceled();
			throw e;
		} finally {
			workspace.endOperation(true, Policy.subMonitorFor(monitor, Policy.buildWork));
		}
	} finally {
		monitor.done();
	}
}
/**
 * Helper method that considers case insensitive file systems.
 */
protected void checkDoesNotExist() throws CoreException {
	// should consider getting the ResourceInfo as a paramenter to reduce tree lookups
	
	//first check the tree for an exact case match
	checkDoesNotExist(getFlags(getResourceInfo(false, false)), false);
	if (CoreFileSystemLibrary.isCaseSensitive()) {
		return;
	}
	//now look for a matching case variant in the tree
	IResource variant = findExistingResourceVariant(getFullPath());
	if (variant == null)
		return;
	String msg = Policy.bind("resources.existsDifferentCase", variant.getFullPath().toString());
	throw new ResourceException(IResourceStatus.CASE_VARIANT_EXISTS, variant.getFullPath(), msg, null);
}
/**
 * Helper method for case insensitive file systems.  Returns
 * an existing resource whose path differs only in case from
 * the given path, or null if no such resource exists.
 */
public IResource findExistingResourceVariant(IPath target) {
	IPath result = Path.ROOT;
	int segmentCount = target.segmentCount();
	for (int i = 0; i < segmentCount; i++) {
		String[] childNames = workspace.tree.getNamesOfChildren(result);
		String name = findVariant(target.segment(i), childNames);
		if (name == null)
			return null;
		result = result.append(name);
	}
	return workspace.getRoot().findMember(result);
}
/**
 * Searches for a variant of the given target in the list,
 * that differs only in case. Returns the variant from
 * the list if one is found, otherwise returns null.
 */
private String findVariant(String target, String[] list) {
	for (int i = 0; i < list.length; i++) {
		if (target.equalsIgnoreCase(list[i]))
			return list[i];
	}
	return null;
}

/*
 * @see IResource
 */
public boolean isDerived() {
	// FIXME - missing implementation
	return false;
}

/*
 * @see IResource
 */
public void setDerived(boolean isDerived) throws CoreException {
	// FIXME - missing implementation
}

/*
 * @see IResource
 */
public boolean isTeamPrivateMember() {
	// FIXME - missing implementation
	return false;
}

/*
 * @see IResource
 */
public void setTeamPrivateMember(boolean isTeamPrivate) throws CoreException {
	// FIXME - missing implementation
}

}