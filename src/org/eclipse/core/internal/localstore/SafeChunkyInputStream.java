package org.eclipse.core.internal.localstore;/* * (c) Copyright IBM Corp. 2000, 2001. * All Rights Reserved. */import java.io.*;/** * @see SafeChunkyOutputStream */public class SafeChunkyInputStream extends InputStream {	protected InputStream input;	protected byte[] buffer;	protected byte[] chunk;	protected boolean endOfFile = false;	protected int nextByteInBuffer = 0;	protected int bufferLength = 0;	protected int nextByteInChunk = 0;	protected int chunkLength = 0;	protected static final int BUFFER_SIZE = 8192;public SafeChunkyInputStream(File target) throws IOException {	this(target.getAbsolutePath());}public SafeChunkyInputStream(String filePath) throws IOException {	input = new BufferedInputStream(new FileInputStream(filePath));	buffer = new byte[BUFFER_SIZE];}public int available() throws IOException {	return chunkLength - nextByteInChunk;}public void close() throws IOException {	input.close();}protected boolean compare(byte[] target, int startIndex) {	for (int i = 0; i < target.length; i++) {		if (buffer[startIndex] != target[i])			return false;		startIndex++;	}	return true;}protected int find(byte[] pattern, int startIndex, int endIndex, boolean accumulate) throws IOException {	int pos = findByte(pattern[0], startIndex, endIndex);	if (pos == -1)		return -1;	if (pos + 16 > bufferLength) {		if (accumulate) 			accumulate(buffer, nextByteInBuffer, pos);		nextByteInBuffer = pos;		pos = 0;		shiftAndFillBuffer();	}	if (compare(pattern, pos))		return pos;	else		return find(pattern, pos + 1, endIndex, accumulate);}/** * @param endIndex is exclusive */protected int findByte(byte target, int startIndex, int endIndex) {	while (startIndex < endIndex) {		if (buffer[startIndex] == target)			return startIndex;		startIndex++;	}	return -1;}protected void accumulate(byte[] data, int start, int end)  {	byte[] result = new byte[chunk.length + end - start];	System.arraycopy(chunk, 0, result, 0, chunk.length);	System.arraycopy(data, start, result, chunk.length, end - start);	chunk = result;	chunkLength = chunkLength + end - start;}protected void shiftAndFillBuffer() throws IOException {	int length = bufferLength - nextByteInBuffer;	System.arraycopy(buffer, nextByteInBuffer, buffer, 0, length);	nextByteInBuffer = 0;	bufferLength = length;	int read = input.read(buffer, bufferLength, buffer.length - bufferLength);	if (read != -1) 		bufferLength += read;	else {		resetChunk();		endOfFile = true;	}}protected void findChunkStart() throws IOException {	if (nextByteInBuffer + ILocalStoreConstants.CHUNK_DELIMITER_SIZE > bufferLength) 		shiftAndFillBuffer();	int begin = find(ILocalStoreConstants.BEGIN_CHUNK, nextByteInBuffer, bufferLength, false);	if (begin != -1) {		nextByteInBuffer = begin + ILocalStoreConstants.CHUNK_DELIMITER_SIZE;		return;	}	bufferLength = input.read(buffer);	nextByteInBuffer = 0;	if (bufferLength == -1) {		resetChunk();		endOfFile = true;		return;	}	findChunkStart();}protected void buildChunk() throws IOException {	if (nextByteInBuffer + ILocalStoreConstants.CHUNK_DELIMITER_SIZE > bufferLength) 		shiftAndFillBuffer();	int end = find(ILocalStoreConstants.END_CHUNK, nextByteInBuffer, bufferLength, true);	if (end != -1) {		accumulate(buffer, nextByteInBuffer, end);		nextByteInBuffer = end + ILocalStoreConstants.CHUNK_DELIMITER_SIZE;		return;	}	accumulate(buffer, nextByteInBuffer, bufferLength);	bufferLength = input.read(buffer);	nextByteInBuffer = 0;	if (bufferLength == -1) {		endOfFile = true;		return;	}	buildChunk();}protected void resetChunk() {	chunk = new byte[0];	chunkLength = 0;	nextByteInChunk = 0;}public int read() throws IOException {	if (endOfFile)		return -1;	if (nextByteInChunk == chunkLength) {		resetChunk();		findChunkStart();		if (endOfFile)			return -1;		buildChunk();	}	if (endOfFile)		return -1;	return chunk[nextByteInChunk++] & 0xFF;}}